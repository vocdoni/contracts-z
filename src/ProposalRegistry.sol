// SPDX-License-Identifier: AGPL-3.0-or-later
pragma solidity 0.8.24;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "./OrganizationRegistry.sol";

contract ProposalRegistry is Initializable, UUPSUpgradeable, OwnableUpgradeable {

    event ProposalCreated(bytes32 indexed proposalID, address indexed creator);
    event ProposalStatusChanged(bytes32 indexed proposalID, ProposalStatus newStatus);
    event CensusUpdated(bytes32 indexed proposalID, bytes32 censusRoot, string censusURI, uint256 maxCensusSize);
    event ProposalDurationChanged(bytes32 indexed proposalID, uint256 duration);

    enum ProposalStatus {
        READY,
        ENDED,
        CANCELED,
        PAUSED,
        RESULTS
    }

    enum CensusOrigin {
        CENSUS_UNKNOWN,
        OFF_CHAIN_TREE,
        OFF_CHAIN_TREE_WEIGHTED,
        OFF_CHAIN_CA,
        ERC20,
        ERC721,
        ERC1155,
        ERC777,
        MINI_ME,
        FARCASTER_FRAME
    }

    /**
     * @notice The envelope type tells how the vote envelope will be formatted and handled. Its value is generated by combining the flags below.
     *
     * 0b00011111
     *      |||||
     *      ||||`- serial
     *      |||`-- anonymous
     *      ||`--- encryptedVote
     *      |`---- uniqueValues
     *      `----- costFromWeight
    */
    uint8 internal constant ENVELOPE_TYPE_SERIAL = 1 << 0;           
    uint8 internal constant ENVELOPE_TYPE_ANONYMOUS = 1 << 1;        
    uint8 internal constant ENVELOPE_TYPE_ENCRYPTED_VOTES = 1 << 2;  
    uint8 internal constant ENVELOPE_TYPE_UNIQUE_VALUES = 1 << 3;    
    uint8 internal constant ENVELOPE_TYPE_COST_FROM_WEIGHT = 1 << 4;
    
    /**
     * @notice The process mode defines how the process behaves externally. It affects both the Vochain, the contract itself, the metadata and the census origin.
     *   
     * 0b00011111
     *      |||||
     *      ||||`- autoStart
     *      |||`-- interruptible
     *      ||`--- dynamicCensus
     *      |`---- encryptedMetadata
     *      `----- preregister
    */
    uint8 internal constant PROPOSAL_MODE_AUTO_START = 1 << 0;
    uint8 internal constant PROPOSAL_MODE_INTERRUPTIBLE = 1 << 1;
    uint8 internal constant PROPOSAL_MODE_DYNAMIC_CENSUS = 1 << 2;
    uint8 internal constant PROPOSAL_MODE_ENCRYPTED_METADATA = 1 << 3;
    uint8 internal constant PROPOSAL_MODE_PREREGISTER = 1 << 4;

    struct VoteOptions {
        uint32 maxCount;
        uint32 maxValue;
        uint32 maxOverwrites;
        uint32 maxTotalCost;
        uint32 costExponent;
    }

    struct ProposalOptions {
        uint8 envelopeType;
        uint8 proposalMode;
        uint256 startTime;
        uint256 duration;
        ProposalStatus status;
        VoteOptions voteOptions;
    }

    struct Census {
        CensusOrigin censusOrigin;
        uint256 maxCensusSize;
        bytes32 censusRoot;
        string censusURI;
    }

    struct ProposalID {
        CensusOrigin censusOrigin;
        uint8 envType;
        uint32 nonce;
        bytes32 organizationID;
        string chainID;
    }

    struct Proposal {
        ProposalStatus status;
        bytes32 organizationId;
        uint256[][] result;
        uint256 startTime;
        uint256 duration;
        string metadataURI;
        ProposalOptions options;
        Census census;
    }

    mapping(bytes32 => Proposal) public proposals;
    address public organizationRegistry;
    uint32 public proposalCount;
    string public chainID;

    function initialize(string calldata _chainID, address _organizationRegistry) public initializer {
        __Ownable_init(msg.sender);
        __UUPSUpgradeable_init();
        chainID = _chainID;
        organizationRegistry = _organizationRegistry;
    }

    function NewProposal(ProposalOptions calldata options, Census calldata census, string calldata metadata, bytes32 organizationID) public {
        require(options.voteOptions.maxCount > 0, "NewProposal: invalid maxCount");
        require(options.voteOptions.maxValue > options.voteOptions.maxCount, "NewProposal: maxCount > maxValue");
        require(options.status == ProposalStatus.READY || options.status == ProposalStatus.PAUSED, "NewProposal: invalid status");
        if (census.censusOrigin == CensusOrigin.OFF_CHAIN_CA) {
            require(options.envelopeType & ENVELOPE_TYPE_ANONYMOUS == 0, "NewProposal: census origin CA requires non-anonymous envelope type");
        }
        if (census.censusOrigin == CensusOrigin.FARCASTER_FRAME) {
            require(options.voteOptions.maxCount == 1, "NewProposal: maxCount must be 1 for Farcaster");
            require(options.envelopeType & ENVELOPE_TYPE_ANONYMOUS == 0, "NewProposal: census origin Farcaster requires non-anonymous envelope type");
            require(options.envelopeType & ENVELOPE_TYPE_ENCRYPTED_VOTES == 0, "NewProposal: census origin Farcaster requires non-encrypted envelope type");
        }
        require(options.startTime > block.timestamp, "NewProposal: invalid startTime");
        require(options.startTime + options.duration > block.timestamp, "NewProposal: invalid duration");
        require(options.envelopeType & ENVELOPE_TYPE_SERIAL == 0, "NewProposal: serial envelope type not implemented");
        require(OrganizationRegistry(organizationRegistry).isAdministrator(organizationID, msg.sender), "NewProposal: not an administrator");
        
        Proposal memory p = Proposal({
            status: options.status,
            organizationId: organizationID,
            result: new uint256[][](0),
            startTime: options.startTime,
            duration: options.duration,
            metadataURI: metadata,
            options: options,
            census: census
        });

        ProposalID memory pID = ProposalID({
            censusOrigin: census.censusOrigin,
            envType: options.envelopeType,
            nonce: proposalCount,
            organizationID: organizationID,
            chainID: chainID
        });

        bytes32 proposalID = buildProposalID(pID);

        proposals[proposalID] = p;

        emit ProposalCreated(proposalID, msg.sender);
    }

    function buildProposalID(ProposalID memory p) public pure returns (bytes32) {
        bytes32 chainIDHash = keccak256(bytes(p.chainID));
        bytes memory chainIDBytes = new bytes(6);
        for (uint256 i = 0; i < 6; i++) {
            chainIDBytes[i] = chainIDHash[i];
        }
        bytes memory idBytes = abi.encodePacked(
            chainIDBytes,                                   // 6 bytes
            bytes20(uint160(uint256(p.organizationID))),    // 20 bytes
            bytes1(uint8(p.censusOrigin)),                  // 1 byte
            bytes1(uint8(p.envType)),                       // 1 byte
            bytes4(p.nonce)                                 // 4 bytes
        );
        bytes32 proposalID;
        assembly {
            proposalID := mload(add(idBytes, 32))
        }
        return proposalID;
    }

    function getProposal(bytes32 proposalID) public view returns (Proposal memory) {
        return proposals[proposalID];
    }

    function SetProposalStatus(bytes32 proposalID, ProposalStatus newStatus) public {
        require(OrganizationRegistry(organizationRegistry).isAdministrator(proposals[proposalID].organizationId, msg.sender), "SetProposalStatus: not an administrator");
        
        ProposalStatus currentStatus = proposals[proposalID].status;
        if (currentStatus != ProposalStatus.READY && currentStatus != ProposalStatus.PAUSED) {
            // When currentStatus is [ENDED, CANCELED, RESULTS], no update is allowed
            revert("Process terminated");
        } else if (currentStatus == ProposalStatus.PAUSED) {
            if (proposals[proposalID].options.proposalMode & PROPOSAL_MODE_INTERRUPTIBLE == 0) {
                // Is not interruptible, we can only go from PAUSED to READY, the first time
                require(newStatus == ProposalStatus.READY, "Not interruptible");
            }
        } else {
            // currentStatus is READY
            if (proposals[proposalID].options.proposalMode & PROPOSAL_MODE_INTERRUPTIBLE == 0) {
                // If not interruptible, no status update is allowed
                revert("Not interruptible");
            }
        }

        // If currentStatus is READY => Can go to [ENDED, CANCELED, PAUSED].
        // If currentStatus is PAUSED => Can go to [READY, ENDED, CANCELED].
        require(newStatus != currentStatus, "Must differ");

        proposals[proposalID].status = newStatus;

        emit ProposalStatusChanged(proposalID, newStatus);
    }

    function SetProposalCensus(bytes32 proposalID, Census calldata census) public {
        require(OrganizationRegistry(organizationRegistry).isAdministrator(proposals[proposalID].organizationId, msg.sender), "SetProposalCensus: not an administrator");

        // check census URI is not empty
        require(bytes(census.censusURI).length > 0, "Empty URI");
        // check census root is not empty
        require(census.censusRoot != 0, "Empty root");

        // check if the proposal exists
        require(proposals[proposalID].organizationId != 0, "Proposal not found");

        // Only if the process is ongoing
        require(
            proposals[proposalID].status == ProposalStatus.READY ||
                proposals[proposalID].status == ProposalStatus.PAUSED,
            "Process terminated"
        );
        
        require(
            proposals[proposalID].options.proposalMode & PROPOSAL_MODE_DYNAMIC_CENSUS != 0,
            "Read-only census"
        );

        if (proposals[proposalID].census.maxCensusSize < census.maxCensusSize) {
            proposals[proposalID].census.maxCensusSize = census.maxCensusSize;
        }

        proposals[proposalID].census.censusRoot = census.censusRoot;
        proposals[proposalID].census.censusURI = census.censusURI;

        emit CensusUpdated(proposalID, census.censusRoot, census.censusURI, census.maxCensusSize);
    }

    function SetProposalDuration(bytes32 proposalID, uint256 duration) public {
        require(OrganizationRegistry(organizationRegistry).isAdministrator(proposals[proposalID].organizationId, msg.sender), "SetProposalDuration: not an administrator");

        // check if the proposal exists
        require(proposals[proposalID].organizationId != 0, "Proposal not found");

        // Only if the process is ongoing
        require(
            proposals[proposalID].status == ProposalStatus.READY ||
                proposals[proposalID].status == ProposalStatus.PAUSED,
            "Process terminated"
        );

        require(duration > block.timestamp, "Invalid duration");
        proposals[proposalID].duration = duration;

        emit ProposalDurationChanged(proposalID, duration);
    }

    function SetProposalResult(bytes32 proposalID, uint256[][] memory result) public {
        // require sequencer from sequencer registry
        // TODO

        require(proposals[proposalID].organizationId != 0, "Proposal not found");

        require(block.timestamp > proposals[proposalID].startTime + proposals[proposalID].duration, "Process ongoing");
        require(proposals[proposalID].status != ProposalStatus.RESULTS && proposals[proposalID].status != ProposalStatus.CANCELED, "Invalid status for setting result");

        proposals[proposalID].result = result;
        proposals[proposalID].status = ProposalStatus.RESULTS;
    }

    function _authorizeUpgrade(address) internal override onlyOwner {}
}