// SPDX-License-Identifier: AGPL-3.0-or-later
pragma solidity 0.8.24;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "./OrganizationRegistry.sol";

contract ProposalRegistry is Initializable, UUPSUpgradeable, OwnableUpgradeable {

    event ProposalCreated(bytes32 indexed proposalID, address indexed creator);
    event ProposalStatusChanged(bytes32 indexed proposalID, ProposalStatus newStatus);
    event CensusUpdated(bytes32 indexed proposalID, bytes32 censusRoot, string censusURI, uint256 maxCensusSize);
    event ProposalDurationChanged(bytes32 indexed proposalID, uint256 duration);
    event ProposalStateRootUpdated(bytes32 indexed proposalID, bytes32 newStateRoot);

    enum ProposalStatus {
        READY,
        ENDED,
        CANCELED,
        PAUSED,
        RESULTS
    }

    enum CensusOrigin {
        CENSUS_UNKNOWN,
        OFF_CHAIN_TREE,
        OFF_CHAIN_TREE_WEIGHTED,
        OFF_CHAIN_CA,
        ERC20,
        ERC721,
        ERC1155,
        ERC777,
        MINI_ME,
        FARCASTER_FRAME
    }

    /**
     * @notice The envelope type tells how the vote envelope will be formatted and handled. Its value is generated by combining the flags below.
     *
     * 0b00011111
     *      |||||
     *      ||||`- serial
     *      |||`-- anonymous
     *      ||`--- encryptedVote
     *      |`---- uniqueValues
     *      `----- costFromWeight
    */
    uint8 internal constant ENVELOPE_TYPE_SERIAL = 1 << 0;           
    uint8 internal constant ENVELOPE_TYPE_ANONYMOUS = 1 << 1;        
    uint8 internal constant ENVELOPE_TYPE_ENCRYPTED_VOTES = 1 << 2;  
    uint8 internal constant ENVELOPE_TYPE_UNIQUE_VALUES = 1 << 3;    
    uint8 internal constant ENVELOPE_TYPE_COST_FROM_WEIGHT = 1 << 4;
    
    /**
     * @notice The process mode defines how the process behaves externally. It affects both the Vochain, the contract itself, the metadata and the census origin.
     *   
     * 0b00011111
     *      |||||
     *      ||||`- autoStart
     *      |||`-- interruptible
     *      ||`--- dynamicCensus
     *      |`---- encryptedMetadata
     *      `----- preregister
    */
    uint8 internal constant PROPOSAL_MODE_AUTO_START = 1 << 0;
    uint8 internal constant PROPOSAL_MODE_INTERRUPTIBLE = 1 << 1;
    uint8 internal constant PROPOSAL_MODE_DYNAMIC_CENSUS = 1 << 2;
    uint8 internal constant PROPOSAL_MODE_ENCRYPTED_METADATA = 1 << 3;
    uint8 internal constant PROPOSAL_MODE_PREREGISTER = 1 << 4;

    struct VoteOptions {
        uint32 maxCount;
        uint32 maxValue;
        uint32 maxOverwrites;
        uint32 maxTotalCost;
        uint32 costExponent;
    }

    struct ProposalOptions {
        uint8 envelopeType;
        uint8 proposalMode;
        uint256 startTime;
        uint256 duration;
        ProposalStatus status;
        VoteOptions voteOptions;
    }

    struct Census {
        CensusOrigin censusOrigin;
        uint256 maxCensusSize;
        bytes32 censusRoot;
        string censusURI;
    }

    struct ProposalID {
        uint256 nonce;
        bytes32 organizationID;
        string chainID;
    }

    struct Proposal {
        ProposalStatus status;
        bytes32 organizationId;
        bytes32[2] encryptionKeys;
        bytes32 latestStateRoot;
        uint256[][] result;
        uint256 startTime;
        uint256 duration;
        string metadataURI;
        ProposalOptions options;
        Census census;
    }

    mapping(bytes32 => Proposal) public proposals;
    address public organizationRegistry;
    uint32 public proposalCount;
    string public chainID;

    function initialize(string calldata _chainID, address _organizationRegistry) public initializer {
        __Ownable_init(msg.sender);
        __UUPSUpgradeable_init();
        chainID = _chainID;
        organizationRegistry = _organizationRegistry;
    }

    function NewProposal(
        ProposalOptions calldata _options,
        Census calldata _census,
        string calldata _metadata,
        bytes32 _organizationID,
        bytes32 _proposalID,
        bytes32 _encryptionPubKey,
        bytes32 _initStateRoot
    ) public {
        require(_options.voteOptions.maxCount > 0, "NewProposal: invalid maxCount");
        require(_options.voteOptions.maxValue > _options.voteOptions.maxCount, "NewProposal: maxCount > maxValue");
        require(_options.status == ProposalStatus.READY || _options.status == ProposalStatus.PAUSED, "NewProposal: invalid status");
        if (_census.censusOrigin == CensusOrigin.OFF_CHAIN_CA) {
            require(_options.envelopeType & ENVELOPE_TYPE_ANONYMOUS == 0, "NewProposal: census origin CA requires non-anonymous envelope type");
        }
        if (_census.censusOrigin == CensusOrigin.FARCASTER_FRAME) {
            require(_options.voteOptions.maxCount == 1, "NewProposal: maxCount must be 1 for Farcaster");
            require(_options.envelopeType & ENVELOPE_TYPE_ANONYMOUS == 0, "NewProposal: census origin Farcaster requires non-anonymous envelope type");
            require(_options.envelopeType & ENVELOPE_TYPE_ENCRYPTED_VOTES == 0, "NewProposal: census origin Farcaster requires non-encrypted envelope type");
        }
        require(_options.startTime > block.timestamp, "NewProposal: invalid startTime");
        require(_options.startTime + _options.duration > block.timestamp, "NewProposal: invalid duration");
        require(_options.envelopeType & ENVELOPE_TYPE_SERIAL == 0, "NewProposal: serial envelope type not implemented");
        require(OrganizationRegistry(organizationRegistry).isAdministrator(_organizationID, msg.sender), "NewProposal: not an administrator");
        
        if (proposals[_proposalID].organizationId != 0) {
            revert("NewProposal: proposal already exists");
        }

        Proposal memory p = Proposal({
            status: _options.status,
            organizationId: _organizationID,
            encryptionKeys: [_encryptionPubKey, bytes32(0)],
            latestStateRoot: _initStateRoot,
            result: new uint256[][](0),
            startTime: _options.startTime,
            duration: _options.duration,
            metadataURI: _metadata,
            options: _options,
            census: _census
        });
        
        proposals[_proposalID] = p;

        emit ProposalCreated(_proposalID, msg.sender);
    }

    function getProposal(bytes32 proposalID) public view returns (Proposal memory) {
        return proposals[proposalID];
    }

    function SetProposalStatus(bytes32 proposalID, ProposalStatus newStatus) public {
        require(OrganizationRegistry(organizationRegistry).isAdministrator(proposals[proposalID].organizationId, msg.sender), "SetProposalStatus: not an administrator");
        
        ProposalStatus currentStatus = proposals[proposalID].status;
        if (currentStatus != ProposalStatus.READY && currentStatus != ProposalStatus.PAUSED) {
            // When currentStatus is [ENDED, CANCELED, RESULTS], no update is allowed
            revert("Process terminated");
        } else if (currentStatus == ProposalStatus.PAUSED) {
            if (proposals[proposalID].options.proposalMode & PROPOSAL_MODE_INTERRUPTIBLE == 0) {
                // Is not interruptible, we can only go from PAUSED to READY, the first time
                require(newStatus == ProposalStatus.READY, "Not interruptible");
            }
        } else {
            // currentStatus is READY
            if (proposals[proposalID].options.proposalMode & PROPOSAL_MODE_INTERRUPTIBLE == 0) {
                // If not interruptible, no status update is allowed
                revert("Not interruptible");
            }
        }

        // If currentStatus is READY => Can go to [ENDED, CANCELED, PAUSED].
        // If currentStatus is PAUSED => Can go to [READY, ENDED, CANCELED].
        require(newStatus != currentStatus, "Must differ");

        proposals[proposalID].status = newStatus;

        emit ProposalStatusChanged(proposalID, newStatus);
    }

    function SetProposalCensus(bytes32 proposalID, Census calldata census) public {
        require(OrganizationRegistry(organizationRegistry).isAdministrator(proposals[proposalID].organizationId, msg.sender), "SetProposalCensus: not an administrator");

        // check census URI is not empty
        require(bytes(census.censusURI).length > 0, "Empty URI");
        // check census root is not empty
        require(census.censusRoot != 0, "Empty root");

        // check if the proposal exists
        require(proposals[proposalID].organizationId != 0, "Proposal not found");

        // Only if the process is ongoing
        require(
            proposals[proposalID].status == ProposalStatus.READY ||
                proposals[proposalID].status == ProposalStatus.PAUSED,
            "Process terminated"
        );
        
        require(
            proposals[proposalID].options.proposalMode & PROPOSAL_MODE_DYNAMIC_CENSUS != 0,
            "Read-only census"
        );

        if (proposals[proposalID].census.maxCensusSize < census.maxCensusSize) {
            proposals[proposalID].census.maxCensusSize = census.maxCensusSize;
        }

        proposals[proposalID].census.censusRoot = census.censusRoot;
        proposals[proposalID].census.censusURI = census.censusURI;

        emit CensusUpdated(proposalID, census.censusRoot, census.censusURI, census.maxCensusSize);
    }

    function SetProposalDuration(bytes32 proposalID, uint256 duration) public {
        require(OrganizationRegistry(organizationRegistry).isAdministrator(proposals[proposalID].organizationId, msg.sender), "SetProposalDuration: not an administrator");

        // check if the proposal exists
        require(proposals[proposalID].organizationId != 0, "Proposal not found");

        // Only if the process is ongoing
        require(
            proposals[proposalID].status == ProposalStatus.READY ||
                proposals[proposalID].status == ProposalStatus.PAUSED,
            "Process terminated"
        );

        require(duration > block.timestamp, "Invalid duration");
        proposals[proposalID].duration = duration;

        emit ProposalDurationChanged(proposalID, duration);
    }

    function endProposal(bytes32 proposalID) public {
        require(OrganizationRegistry(organizationRegistry).isAdministrator(proposals[proposalID].organizationId, msg.sender), "endProposal: not an administrator");
        require(proposals[proposalID].status == ProposalStatus.READY || proposals[proposalID].status == ProposalStatus.PAUSED, "Process terminated");
        proposals[proposalID].status = ProposalStatus.ENDED;

        emit ProposalStatusChanged(proposalID, ProposalStatus.ENDED);
    }

    function submitStateTransition(bytes32 _proposalID, bytes32 _oldRoot, bytes32 _newRoot, bytes calldata _proof) public {
        require(proposals[_proposalID].organizationId != 0, "Proposal not found");
        require(proposals[_proposalID].status != ProposalStatus.RESULTS && proposals[_proposalID].status != ProposalStatus.CANCELED, "Invalid status for submitting state transition");
        require(proposals[_proposalID].latestStateRoot == _oldRoot, "Invalid old root");
        // TODO verify proof
        // update state root
        proposals[_proposalID].latestStateRoot = _newRoot;
        emit ProposalStateRootUpdated(_proposalID, _newRoot);
    }

    function SetProposalResult(bytes32 proposalID, uint256[][] memory result, bytes calldata proof) public {
        // require sequencer from sequencer registry
        // TODO

        require(proposals[proposalID].organizationId != 0, "Proposal not found");
        require(proposals[proposalID].status == ProposalStatus.ENDED, "Process not ended");

        // TODO verify proof   

        proposals[proposalID].result = result;
        proposals[proposalID].status = ProposalStatus.RESULTS;
    }

    function _authorizeUpgrade(address) internal override onlyOwner {}
}