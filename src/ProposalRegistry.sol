// SPDX-License-Identifier: AGPL-3.0-or-later
pragma solidity 0.8.24;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "./OrganizationRegistry.sol";

/**
 * @title ProposalRegistry
 * @notice This contract is responsible for storing proposals data and managing their lifecycle.
 */
contract ProposalRegistry is Initializable, UUPSUpgradeable, OwnableUpgradeable {

    /*
     * @notice Emitted when a new proposal is created.
     * @param proposalID The ID of the proposal.
     * @param creator The address of the creator of the proposal.
     */
    event ProposalCreated(bytes32 indexed proposalID, address indexed creator);
    /*
     * @notice Emitted when the status of a proposal is modified.
     * @param proposalID The ID of the proposal.
     * @param newStatus The new status of the proposal.
     */
    event ProposalStatusChanged(bytes32 indexed proposalID, ProposalStatus newStatus);
    /*
     * @notice Emitted when the census of a proposal is updated.
     * @param proposalID The ID of the proposal.
     * @param censusRoot The new root of the census.
     * @param censusURI The URI of the census.
     * @param maxCensusSize The maximum size of the census.
     */
    event CensusUpdated(bytes32 indexed proposalID, bytes32 censusRoot, string censusURI, uint256 maxCensusSize);
    /*
     * @notice Emitted when the duration of a proposal is modified.
     * @param proposalID The ID of the proposal.
     * @param duration The new duration of the proposal.
     */
    event ProposalDurationChanged(bytes32 indexed proposalID, uint256 duration);
    /*
     * @notice Emitted when the state root of a proposal is updated.
     * @param proposalID The ID of the proposal.
     * @param newStateRoot The new state root of the proposal.
     */
    event ProposalStateRootUpdated(bytes32 indexed proposalID, bytes32 newStateRoot);

    /**
     * @notice The proposal status defines the current state of the proposal.
     */
    enum ProposalStatus {
        READY,
        ENDED,
        CANCELED,
        PAUSED,
        RESULTS
    }
    /**
     * @notice The census origin defines the origin of the census data. It affects the way the census is handled.
     */
    enum CensusOrigin {
        CENSUS_UNKNOWN,
        OFF_CHAIN_TREE,
        OFF_CHAIN_TREE_WEIGHTED,
        OFF_CHAIN_CA,
        ERC20,
        ERC721,
        ERC1155,
        ERC777,
        MINI_ME,
        FARCASTER_FRAME
    }
    /**
     * @notice The envelope type tells how the vote envelope will be formatted and handled.
     *         Its value is generated by combining the flags below.
     *
     * 0b00011111
     *      |||||
     *      ||||`- serial
     *      |||`-- anonymous
     *      ||`--- encryptedVote
     *      |`---- uniqueValues
     *      `----- costFromWeight
     */
    uint8 internal constant ENVELOPE_TYPE_SERIAL = 1 << 0;           
    uint8 internal constant ENVELOPE_TYPE_ANONYMOUS = 1 << 1;        
    uint8 internal constant ENVELOPE_TYPE_ENCRYPTED_VOTES = 1 << 2;  
    uint8 internal constant ENVELOPE_TYPE_UNIQUE_VALUES = 1 << 3;    
    uint8 internal constant ENVELOPE_TYPE_COST_FROM_WEIGHT = 1 << 4;
    /**
     * @notice The process mode defines how the process behaves externally.
     *         It affects both the Vochain, the contract itself, the metadata and the census origin.
     *   
     * 0b00011111
     *      |||||
     *      ||||`- autoStart
     *      |||`-- interruptible
     *      ||`--- dynamicCensus
     *      |`---- encryptedMetadata
     *      `----- preregister
     */
    uint8 internal constant PROPOSAL_MODE_AUTO_START = 1 << 0;
    uint8 internal constant PROPOSAL_MODE_INTERRUPTIBLE = 1 << 1;
    uint8 internal constant PROPOSAL_MODE_DYNAMIC_CENSUS = 1 << 2;
    uint8 internal constant PROPOSAL_MODE_ENCRYPTED_METADATA = 1 << 3;
    uint8 internal constant PROPOSAL_MODE_PREREGISTER = 1 << 4;

    /**
     * @notice The vote options define the parameters of the vote.
     * @param uniqueValues Choices cannot appear twice or more.
     * @param maxCount The maximum number of field per ballot.
     * @param maxValue The maximum value for all fields.
     * @param minValue The minimum value for all fields.
     * @param maxOverwrites The maximum number of overwrites allowed.
     * @param maxTotalCost Maximum limit on the total sum of all ballot fields' values. 0 => Not applicable.
     * @param minTotalCost Minimum limit on the total sum of all ballot fields' values. 0 => Not applicable.
     * @param costExponent The exponent that will be used to compute the "cost" of the field values.
     */
    struct VoteOptions {
        bool uniqueValues;
        uint256 maxCount;
        uint256 maxValue;
        uint256 minValue;
        uint256 maxOverwrites;
        uint256 maxTotalCost;
        uint256 minTotalCost;
        uint256 costExponent;
    }
    /**
     * @notice The proposal options define the parameters of the proposal.
     * @param envelopeType The type of the vote envelope.
     * @param proposalMode The mode of the proposal.
     * @param startTime The start time of the proposal.
     * @param duration The duration of the proposal.
     * @param status The status of the proposal.
     * @param voteOptions The vote options of the proposal.
     */
    struct ProposalOptions {
        uint8 envelopeType;
        uint8 proposalMode;
        uint256 startTime;
        uint256 duration;
        ProposalStatus status;
        VoteOptions voteOptions;
    }
    /**
     * @notice The census defines the parameters of the census.
     * @param censusOrigin The origin of the census.
     * @param maxCensusSize The maximum size of the census.
     * @param censusRoot The root of the census.
     * @param censusURI The URI of the census.
     */
    struct Census {
        CensusOrigin censusOrigin;
        uint256 maxCensusSize;
        bytes32 censusRoot;
        string censusURI;
    }
    /**
     * @notice The proposal ID is a unique identifier for a proposal.
     * @param nonce The nonce of the proposal.
     * @param organizationID The ID of the organization.
     * @param chainID The ID of the chain.
     */
    struct ProposalID {
        uint256 nonce;
        bytes32 organizationID;
        string chainID;
    }
    /**
     * @notice The proposal defines the parameters of the proposal.
     * @param status The status of the proposal.
     * @param organizationId The ID of the organization.
     * @param encryptionKeys The encryption keys of the proposal.
     * @param latestStateRoot The latest state root of the proposal.
     * @param result The result of the proposal.
     * @param startTime The start time of the proposal.
     * @param duration The duration of the proposal.
     * @param metadataURI The URI of the metadata.
     * @param options The options of the proposal.
     * @param census The census of the proposal.
     */
    struct Proposal {
        ProposalStatus status;
        bytes32 organizationId;
        bytes32[2] encryptionKeys;
        bytes32 latestStateRoot;
        uint256[][] result;
        uint256 startTime;
        uint256 duration;
        string metadataURI;
        ProposalOptions options;
        Census census;
    }

    /**
     * @notice The proposals mapping is a mapping of proposal IDs to proposals.
     */
    mapping(bytes32 => Proposal) public proposals;
    /**
     * @notice The organization registry is the contract address of the organization registry.
     */
    address public organizationRegistry;
    /**
     * @notice The proposal count is the number of proposals created.
     */
    uint32 public proposalCount;
    /**
     * @notice The chain ID is the ID of the chain.
     */
    string public chainID;

    /**
     * @notice Initializes the contract.
     * @param _chainID The ID of the chain.
     * @param _organizationRegistry The address of the organization registry.
     */
    function initialize(string calldata _chainID, address _organizationRegistry) public initializer {
        __Ownable_init(msg.sender);
        __UUPSUpgradeable_init();
        chainID = _chainID;
        organizationRegistry = _organizationRegistry;
    }

    /**
     * @notice Creates a new proposal.
     * @param _options The options of the proposal.
     * @param _census The census of the proposal.
     * @param _metadata The URI of the metadata.
     * @param _organizationID The ID of the organization.
     * @param _proposalID The ID of the proposal.
     * @param _encryptionPubKey The public key of the encryption.
     * @param _initStateRoot The initial state root.
     */
    function NewProposal(
        ProposalOptions calldata _options,
        Census calldata _census,
        string calldata _metadata,
        bytes32 _organizationID,
        bytes32 _proposalID,
        bytes32 _encryptionPubKey,
        bytes32 _initStateRoot
    ) public {
        require(_options.voteOptions.maxCount > 0, "NewProposal: invalid maxCount");
        require(_options.voteOptions.maxValue > _options.voteOptions.maxCount, "NewProposal: maxCount > maxValue");
        require(
            _options.status == ProposalStatus.READY || _options.status == ProposalStatus.PAUSED,
            "NewProposal: invalid status"
        );
        if (_census.censusOrigin == CensusOrigin.OFF_CHAIN_CA) {
            require(
                _options.envelopeType & ENVELOPE_TYPE_ANONYMOUS == 0,
                "NewProposal: census origin CA requires non-anonymous envelope type"
            );
        }
        if (_census.censusOrigin == CensusOrigin.FARCASTER_FRAME) {
            require(_options.voteOptions.maxCount == 1, "NewProposal: maxCount must be 1 for Farcaster");
            require(
                _options.envelopeType & ENVELOPE_TYPE_ANONYMOUS == 0,
                "NewProposal: census origin Farcaster requires non-anonymous envelope type"
            );
            require(
                _options.envelopeType & ENVELOPE_TYPE_ENCRYPTED_VOTES == 0,
                "NewProposal: census origin Farcaster requires non-encrypted envelope type"
            );
        }
        require(_options.startTime > block.timestamp, "NewProposal: invalid startTime");
        require(_options.startTime + _options.duration > block.timestamp, "NewProposal: invalid duration");
        require(_options.envelopeType & ENVELOPE_TYPE_SERIAL == 0, "NewProposal: serial envelope type not implemented");
        require(
            OrganizationRegistry(organizationRegistry).isAdministrator(_organizationID, msg.sender),
            "NewProposal: not an administrator"
        );
        
        if (proposals[_proposalID].organizationId != 0) {
            revert("NewProposal: proposal already exists");
        }

        Proposal memory p = Proposal({
            status: _options.status,
            organizationId: _organizationID,
            encryptionKeys: [_encryptionPubKey, bytes32(0)],
            latestStateRoot: _initStateRoot,
            result: new uint256[][](0),
            startTime: _options.startTime,
            duration: _options.duration,
            metadataURI: _metadata,
            options: _options,
            census: _census
        });
        
        proposals[_proposalID] = p;

        emit ProposalCreated(_proposalID, msg.sender);
    }

    /**
     * @notice Returns the proposal data.
     * @param _proposalID The ID of the proposal.
     * @return The proposal data.
     */
    function getProposal(bytes32 _proposalID) public view returns (Proposal memory) {
        return proposals[_proposalID];
    }

    /**
     * @notice Sets the status of a proposal.
     * @param _proposalID The ID of the proposal.
     * @param _newStatus The new status of the proposal.
     */
    function SetProposalStatus(bytes32 _proposalID, ProposalStatus _newStatus) public {
        require(
            OrganizationRegistry(organizationRegistry).isAdministrator(
                proposals[_proposalID].organizationId,
                msg.sender
            ),
            "SetProposalStatus: not an administrator"
        );
        
        ProposalStatus currentStatus = proposals[_proposalID].status;
        if (currentStatus != ProposalStatus.READY && currentStatus != ProposalStatus.PAUSED) {
            // When currentStatus is [ENDED, CANCELED, RESULTS], no update is allowed
            revert("Process terminated");
        } else if (currentStatus == ProposalStatus.PAUSED) {
            if (proposals[_proposalID].options.proposalMode & PROPOSAL_MODE_INTERRUPTIBLE == 0) {
                // Is not interruptible, we can only go from PAUSED to READY, the first time
                require(_newStatus == ProposalStatus.READY, "Not interruptible");
            }
        } else {
            // currentStatus is READY
            if (proposals[_proposalID].options.proposalMode & PROPOSAL_MODE_INTERRUPTIBLE == 0) {
                // If not interruptible, no status update is allowed
                revert("Not interruptible");
            }
        }

        // If currentStatus is READY => Can go to [ENDED, CANCELED, PAUSED].
        // If currentStatus is PAUSED => Can go to [READY, ENDED, CANCELED].
        require(_newStatus != currentStatus, "Must differ");

        proposals[_proposalID].status = _newStatus;

        emit ProposalStatusChanged(_proposalID, _newStatus);
    }

    /**
     * @notice Sets the census of a proposal.
     * @param _proposalID The ID of the proposal.
     * @param _census The census of the proposal.
     */
    function SetProposalCensus(bytes32 _proposalID, Census calldata _census) public {
        require(
            OrganizationRegistry(organizationRegistry).isAdministrator(
                proposals[_proposalID].organizationId,
                msg.sender
            ),
            "SetProposalCensus: not an administrator"
        );

        // check census URI is not empty
        require(bytes(_census.censusURI).length > 0, "Empty URI");
        // check census root is not empty
        require(_census.censusRoot != 0, "Empty root");

        // check if the proposal exists
        require(proposals[_proposalID].organizationId != 0, "Proposal not found");

        // Only if the process is ongoing
        require(
            proposals[_proposalID].status == ProposalStatus.READY ||
                proposals[_proposalID].status == ProposalStatus.PAUSED,
            "Process terminated"
        );
        
        require(
            proposals[_proposalID].options.proposalMode & PROPOSAL_MODE_DYNAMIC_CENSUS != 0,
            "Read-only census"
        );

        if (proposals[_proposalID].census.maxCensusSize < _census.maxCensusSize) {
            proposals[_proposalID].census.maxCensusSize = _census.maxCensusSize;
        }

        proposals[_proposalID].census.censusRoot = _census.censusRoot;
        proposals[_proposalID].census.censusURI = _census.censusURI;

        emit CensusUpdated(_proposalID, _census.censusRoot, _census.censusURI, _census.maxCensusSize);
    }

    /**
     * @notice Sets the duration of a proposal.
     * @param _proposalID The ID of the proposal.
     * @param _duration The new duration of the proposal.
     */
    function SetProposalDuration(bytes32 _proposalID, uint256 _duration) public {
        require(
            OrganizationRegistry(organizationRegistry).isAdministrator(
                proposals[_proposalID].organizationId,
                msg.sender
            ),
            "SetProposalDuration: not an administrator"
        );

        // check if the proposal exists
        require(proposals[_proposalID].organizationId != 0, "Proposal not found");

        // Only if the process is ongoing
        require(
            proposals[_proposalID].status == ProposalStatus.READY ||
                proposals[_proposalID].status == ProposalStatus.PAUSED,
            "Process terminated"
        );

        require(_duration > block.timestamp, "Invalid duration");
        proposals[_proposalID].duration = _duration;

        emit ProposalDurationChanged(_proposalID, _duration);
    }

    /**
     * @notice Ends a proposal.
     * @param _proposalID The ID of the proposal.
     */
    function endProposal(bytes32 _proposalID) public {
        require(
            OrganizationRegistry(organizationRegistry).isAdministrator(
                proposals[_proposalID].organizationId,
                msg.sender
            ),
            "endProposal: not an administrator"
        );
        require(
            proposals[_proposalID].status == ProposalStatus.READY ||
            proposals[_proposalID].status == ProposalStatus.PAUSED,
            "Process terminated"
        );
        proposals[_proposalID].status = ProposalStatus.ENDED;

        emit ProposalStatusChanged(_proposalID, ProposalStatus.ENDED);
    }

    /**
     * @notice Used to submit a state transition.
     * @param _proposalID The ID of the proposal.
     * @param _oldRoot The old state root.
     * @param _newRoot The new state root.
     * @param _proof The proof of the state transition.
     */
    function submitStateTransition(
        bytes32 _proposalID,
        bytes32 _oldRoot,
        bytes32 _newRoot,
        bytes calldata _proof
    ) public {
        require(proposals[_proposalID].organizationId != 0, "Proposal not found");
        require(
            proposals[_proposalID].status != ProposalStatus.RESULTS &&
            proposals[_proposalID].status != ProposalStatus.CANCELED,
            "Invalid status for submitting state transition"
        );
        require(proposals[_proposalID].latestStateRoot == _oldRoot, "Invalid old root");
        // TODO verify proof
        // update state root
        proposals[_proposalID].latestStateRoot = _newRoot;
        emit ProposalStateRootUpdated(_proposalID, _newRoot);
    }

    /**
     * @notice Sets the result of a proposal.
     * @param _proposalID The ID of the proposal.
     * @param _result The result of the proposal.
     * @param _proof The proof of the result.
     */
    function SetProposalResult(bytes32 _proposalID, uint256[][] memory _result, bytes calldata _proof) public {
        // require sequencer from sequencer registry
        // TODO

        require(proposals[_proposalID].organizationId != 0, "Proposal not found");
        require(proposals[_proposalID].status == ProposalStatus.ENDED, "Process not ended");

        // TODO verify proof   

        proposals[_proposalID].result = _result;
        proposals[_proposalID].status = ProposalStatus.RESULTS;
    }

    function _authorizeUpgrade(address) internal override onlyOwner {}
}